# 수업
1. 싱글톤 디자인으로 자바-sql 다시 작성한다?
2. 자바 코드 작성, 깃허브에 커밋, 이걸 포스트 작성해야하는데.
	1. 싱글톤 수업을 했으면, 다른 코드를 싱글톤으로 재작성하는 실습을 해야하는데
	2. 아직 자바로 뭘 써본적이 없으니까 실습할 재료가 없음
	3. 모듈화 실습
3. 자바 코드 : 쿼리문 실행 부분을 싱글톤 안으로 옮김
4. 자바 코드 : 클로즈 메소드
5. 수업 : html

# java
## lecture project
- 코드 작성, 커밋 내용 정리
### jdbc
- JDBC(Java Database Connectivity) 
- mysql 서버에 연결, 쿼리를 보내고 결과를 받는다
## driver load
```java
Class.forName("com.mysql.cj.jdbc.Driver");
```
- **Driver 로딩**: `Class.forName()` 메소드는 주어진 문자열 이름의 클래스를 로드하고 초기화합니다. 여기서 `"com.mysql.cj.jdbc.Driver"`는 MySQL JDBC 드라이버의 클래스 이름입니다. 이 드라이버 클래스를 로드함으로써, Java 애플리케이션은 MySQL 데이터베이스와 통신할 수 있게 됩니다.
- **JDBC 드라이버 등록**: 이 구문을 실행하면, MySQL JDBC 드라이버가 자동으로 JDBC 드라이버 매니저에 등록됩니다. JDBC 드라이버 매니저는 Java 애플리케이션과 데이터베이스 간의 연결을 관리하는 컴포넌트입니다. 드라이버가 등록되면, JDBC 드라이버 매니저는 `DriverManager.getConnection()` 메소드를 통해 해당 데이터베이스 드라이버를 사용하여 연결을 생성할 수 있습니다.
- **예전 버전의 Java 호환성**: Java 6 이후 버전에서는 JDBC 4.0 API가 도입되어, 드라이버 로딩을 위한 `Class.forName()` 호출이 필수적이지 않게 되었습니다. JDBC 4.0과 호환되는 드라이버들은 자동으로 로드됩니다. 그러나, 여전히 구식 또는 비표준 드라이버를 사용하는 경우나 이전 버전의 Java를 사용하는 경우에는 이 구문이 필요합니다.

> 자동으로 로드되니까 필요 없다


[[2023-11-23-싱글톤]]



# sql.connection을 닫아줘야 하는 이유?
# git
## drop
- 중간 커밋을 드롭하면, 드롭만 제외하고 똑같은 가지가 두개 생긴다.
- 새로운 main을 force push 하면, 새 가지는 사라진다.
- 멀쩡한 방법은 아닌것 같은데
## head
- 해당 브랜치의 최종 커밋
## rebase
- 하나의 커밋에 두개의 파일을 수정했다. 이걸 두개의 커밋으로 쪼개고 싶은데
- https://wikidocs.net/153961
- https://wbluke.tistory.com/26
- 뭐가 어떻게 된건지 솔직히 잘 모르겠다
```
public class App {

    public static void main(String[] args) throws Exception {

  

        // jdbcUtil ju;

        String sql;

        String value;

        java.sql.ResultSet rs;

  

        // 쿼리 보낼 sql 작성

        sql = """

                show tables;

                                                        """;

  
  

        // 쿼리문을 보내고 rs를 받는다

        // conn에 대해서는 신경쓰지 않는다

        System.out.println("쿼리 실행 직전");

        try {

            Thread.sleep(5000);

        } catch (InterruptedException e) {

            e.printStackTrace();

        }

  

        rs = jdbcUtil.sqlQuery(sql);

  

        // 리턴을 출력

        while (rs.next()) {

            // String table_name = rs.getString();

            value = rs.getString(1);

            System.out.println("count: " + value);

        }

  

        // 서버 연결 닫는다

        jdbcUtil.closeConn();

    }

}
// test commit

public class jdbcUtil {

  

    private static String id = "test";

    private static String pw = "test1234";

    private static String url = "jdbc:mysql://localhost:3307/classicmodels";

  

    // 이게 있으면 로드되는 시점에 바로 conn을 만든다??

    // 이게 없으면 jdbcUtil.sqlQuery(sql); 이거 호출하는 시점에 conn을 만든다??

    // 이걸 호출 해야 그때서야 로드 되는 것 같은데?

    private static jdbcUtil instance = new jdbcUtil();

  

    public static jdbcUtil getInstance() {

    return instance;

    }

  

    private static java.sql.Connection conn;

    // conn : static var 이니까

    // static으로 감싼 부분 안에서 변경해야 하는건가?

    static { // 이거 왜 감싸야 하는지 모르겠다

             // 시차를 두고 실행하기 위해

        System.out.println("대기 전");

  
  

        try {

            // 안해도 자동으로 로드된다

            // Class.forName("com.mysql.cj.jdbc.Driver");

            // connection 생성

            conn = java.sql.DriverManager.getConnection(url, id, pw);

            System.out.println("MySQL에 접속 성공!!");

            // } catch (ClassNotFoundException e) {

            // System.out.println("mysql.jdbc.Driver를 생성하다가 오류 발생!!");

            // e.printStackTrace();

        } catch (java.sql.SQLException e) {

            System.out.println("Connection 생성하다가 오류 발생!!");

            e.printStackTrace();

        }

    }

  

    // 쿼리문과 conn을 가지고 rs를 리턴

    // static으로 지정하지 않으면 에러

    // conn을 다루기 때문에 반드시 static이어야 하는건가?

    public static java.sql.ResultSet sqlQuery(String sql) {

        try {

            return conn.prepareStatement(sql).executeQuery();

        } catch (java.sql.SQLException e) {

            System.out.println("쿼리 실행 오류");

            e.printStackTrace();

            return null;

        }

    }

  

    public static void closeConn() {

        try {

            if (conn != null)

                conn.close();

            System.err.println("closed");

        } catch (Exception e) {

            System.err.println("close error");

            e.printStackTrace();

        }

    }

}
```