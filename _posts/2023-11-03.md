## 유사도
- 유클리드 거리
- 코사인
	- 두 점 사이의 거리가 멀더라도 방향이 같으면 유사한 것으로
## NLP
- 언어 -> 단어 -> 벡터
	- 아래로 내려가는게 디코딩 decode?
	- 액션을 하는게 인코딩
	- 아스키 코드를 인코딩 하면 아스키 캐릭터가 된다
	- 문장을 인코딩 하면 벡터가 된다
	- 목적을 가지고 뭘 하면 그게 인코딩?
- 모델에 넣을 수 있는 형태로 변형
- 정제, 정규화
	- 언어를 문자로 표현하는 과정에서 생기는 문제, 이해하는 데 상관 없는 정보들을 제거
- 표제어 추출
	- 사전에서 찾을 수 있도록
- 불용어
	- 관사
- 토큰화
	- 의미 단위로 분해
- integer encoding
	- dict vectorizer
	- bag of word
		- 한 주머니에 담아버리면 순서 정보가 없어진다
		- 빈도를 피처로 삼는다
		- 문장들간의 구분 : 단어들의 빈도 차이
## 노트
- 내가 설명할 수 있는 것만이 실제로 이해한 것
- 또는 원하는 대로 사용할 수 있거나
# 국민대
- 모델 변경
- 로스함수 변경
- 피처 양쪽 각각 한가지씩만 사용하고 새 모델 돌려서 제출
- 평가를 진짜 만들긴 만들어야하는데
	- split 해놓고, test를 얼마나 잘 맞추는지 recall로 측정
	- split 하지 않고, 전체 매트릭스로 recall 측정
- 텐서보드 사용
- 시간계산 사용
```
import torch

def predict_all_scores_and_recall(model, user_features, item_features, user_item_matrix, k=10):
    user_features = torch.from_numpy(user_features).to(device)
    item_features = torch.from_numpy(item_features).to(device)
    user_item_matrix = torch.from_numpy(user_item_matrix).to(device)

    model.eval()  # Set the model to evaluation mode
    user_num, item_num = user_item_matrix.shape
    all_scores = torch.zeros(user_num, item_num).to(device)
    recall_scores = torch.zeros(user_num).to(device)

    with torch.no_grad():
        for user_id in range(user_num):
            # Repeat user features for all items
            user_feature_repeated = user_features[user_id].repeat(item_num, 1).to(device)
            user_id_tensor = torch.tensor([user_id] * item_num).to(device)

            # Get predictions
            scores = model(user_id_tensor, user_feature_repeated, torch.arange(item_num).to(device), item_features).squeeze()
            all_scores[user_id] = scores

            # Calculate recall
            _, top_indices = torch.topk(scores, k)
            true_items = user_item_matrix[user_id] == 1
            num_relevant_items = true_items.sum()
            num_relevant_and_recommended = true_items[top_indices].sum()
            recall_scores[user_id] = num_relevant_and_recommended.float() / num_relevant_items.float() if num_relevant_items > 0 else torch.tensor(0.0).to(device)

    return all_scores, recall_scores

```
# 차원
- 어디서부터 첫번째 차원인지
- shape는 어디서부터 표시되는지
# 임베딩
- 뭐가 어쨌다는건지
- nlp에서도 나오는데
